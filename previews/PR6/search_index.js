var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Solver-Options","page":"API Reference","title":"Solver Options","text":"","category":"section"},{"location":"api/#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"api/#Factorization-Types","page":"API Reference","title":"Factorization Types","text":"","category":"section"},{"location":"api/#Functions","page":"API Reference","title":"Functions","text":"","category":"section"},{"location":"api/#Factorization-and-Solving","page":"API Reference","title":"Factorization and Solving","text":"","category":"section"},{"location":"api/#Enumerations","page":"API Reference","title":"Enumerations","text":"","category":"section"},{"location":"api/#Transpose-Type","page":"API Reference","title":"Transpose Type","text":"","category":"section"},{"location":"api/#Column-Permutation","page":"API Reference","title":"Column Permutation","text":"","category":"section"},{"location":"api/#Row-Permutation","page":"API Reference","title":"Row Permutation","text":"","category":"section"},{"location":"api/#Iterative-Refinement","page":"API Reference","title":"Iterative Refinement","text":"","category":"section"},{"location":"api/#SuperLU.SuperLUOptions","page":"API Reference","title":"SuperLU.SuperLUOptions","text":"SuperLUOptions\n\nUser-friendly options structure for configuring SuperLU solver behavior.\n\nThis structure provides a convenient way to configure SuperLU's solver options without needing to understand the low-level C interface. Options are organized into logical categories for ease of use.\n\nConstructor\n\nSuperLUOptions(;\n    # Permutation options\n    col_perm::colperm_t = COLAMD,\n    row_perm::rowperm_t = LargeDiag_MC64,\n    \n    # Equilibration and scaling\n    equilibrate::Bool = true,\n    \n    # Pivoting options\n    diag_pivot_thresh::Float64 = 1.0,\n    symmetric_mode::Bool = false,\n    \n    # Refinement options\n    iterative_refinement::IterRefine_t = NOREFINE,\n    \n    # Diagnostic options\n    pivot_growth::Bool = false,\n    condition_number::Bool = false,\n    print_stats::Bool = false,\n    \n    # Advanced options\n    replace_tiny_pivot::Bool = false\n)\n\nFields\n\nPermutation Options\n\ncol_perm::colperm_t: Column permutation strategy (default: COLAMD)\nNATURAL: No permutation\nMMD_ATA: Minimum degree on AᵀA\nMMD_AT_PLUS_A: Minimum degree on Aᵀ+A  \nCOLAMD: Column approximate minimum degree (recommended)\nMETIS_AT_PLUS_A: METIS nested dissection\nrow_perm::rowperm_t: Row permutation strategy (default: LargeDiag_MC64)\nNOROWPERM: No row permutation\nLargeDiag_MC64: MC64 algorithm for weighted matching\nLargeDiag_HWPM: Hungarian weighted perfect matching\n\nEquilibration and Scaling\n\nequilibrate::Bool: Whether to equilibrate (scale) the matrix (default: true) Row and column scaling can improve numerical stability.\n\nPivoting Options\n\ndiag_pivot_thresh::Float64: Diagonal pivot threshold (default: 1.0) Controls when off-diagonal elements are preferred over diagonal elements. Range: [0.0, 1.0]. Value of 1.0 means always prefer diagonal (partial pivoting). Value of 0.0 means never prefer diagonal (complete pivoting).\nsymmetric_mode::Bool: Symmetric mode (default: false) When true, uses symmetric storage and factorization patterns. Only applies to structurally symmetric matrices.\n\nRefinement Options\n\niterative_refinement::IterRefine_t: Iterative refinement strategy (default: NOREFINE)\nNOREFINE: No refinement (fastest)\nSLU_SINGLE: Single precision refinement\nSLU_DOUBLE: Double precision refinement  \nSLU_EXTRA: Extra precision refinement (most accurate)\n\nDiagnostic Options\n\npivot_growth::Bool: Compute reciprocal pivot growth factor (default: false)\ncondition_number::Bool: Estimate condition number (default: false)\nprint_stats::Bool: Print solver statistics (default: false)\n\nAdvanced Options\n\nreplace_tiny_pivot::Bool: Replace tiny pivots (default: false) When true, tiny pivots are replaced to improve stability.\n\nExample\n\n# Create options with custom column permutation and iterative refinement\nopts = SuperLUOptions(\n    col_perm = METIS_AT_PLUS_A,\n    iterative_refinement = SLU_DOUBLE,\n    equilibrate = true\n)\n\n# Create factorization with these options\nF = SuperLUFactorize(A; options=opts)\n\nSee also: colperm_t, rowperm_t, IterRefine_t\n\n\n\n\n\n","category":"type"},{"location":"api/#SuperLU.SuperLUFactorization","page":"API Reference","title":"SuperLU.SuperLUFactorization","text":"SuperLUFactorization(; reuse_symbolic::Bool = true, options::SuperLUOptions = SuperLUOptions())\n\nA LinearSolve.jl compatible factorization algorithm using SuperLU for sparse matrices. Supports complex double precision (ComplexF64) matrices.\n\nRequires loading LinearSolve.jl to use with LinearSolve's solve interface.\n\nArguments\n\nreuse_symbolic::Bool = true: If true, the symbolic factorization from a  previous solve will be reused when solving with a new matrix that has the same  sparsity pattern. If false, a complete factorization is performed each time.\noptions::SuperLUOptions = SuperLUOptions(): Solver configuration options. See SuperLUOptions for available settings.\n\nExample\n\nusing SuperLU, LinearSolve, SparseArrays\n\nA = sparse([1.0+0im 2.0; 3.0 4.0])\nb = [1.0+0im, 2.0]\nprob = LinearProblem(A, b)\nsol = solve(prob, SuperLUFactorization())\n\n# With custom options\nopts = SuperLUOptions(col_perm = METIS_AT_PLUS_A, equilibrate = true)\nsol = solve(prob, SuperLUFactorization(options = opts))\n\nSee also: SuperLUOptions, SuperLUFactorize\n\n\n\n\n\n","category":"type"},{"location":"api/#SuperLU.SuperLUFactorize","page":"API Reference","title":"SuperLU.SuperLUFactorize","text":"SuperLUFactorize\n\nA mutable struct that holds the LU factorization of a sparse matrix using SuperLU. This includes the L and U factors, permutation vectors, and other data needed for solving linear systems.\n\nFields\n\nn::Int: Matrix dimension\nnnz::Int: Number of non-zeros\nfactorized::Bool: Whether factorization has been performed\nsymbolic_done::Bool: Whether symbolic factorization is complete\n\nConstructor\n\nSuperLUFactorize(A::SparseMatrixCSC{ComplexF64}; options::SuperLUOptions=SuperLUOptions())\n\nCreate a new factorization object for the sparse matrix A.\n\nArguments\n\nA: Sparse matrix to factorize (must be square)\noptions: Solver options (see SuperLUOptions)\n\nExample\n\nusing SuperLU, SparseArrays\n\nA = sparse([1.0+1.0im 2.0+0im; 3.0-1.0im 4.0+2.0im])\nF = SuperLUFactorize(A)\nfactorize!(F)\nx = superlu_solve(F, [1.0+0im, 2.0+1.0im])\n\nSee also: SuperLUOptions, factorize!, superlu_solve!\n\n\n\n\n\n","category":"type"},{"location":"api/#SuperLU.factorize!","page":"API Reference","title":"SuperLU.factorize!","text":"factorize!(F::SuperLUFactorize)\n\nPerform LU factorization using SuperLU.\n\n\n\n\n\n","category":"function"},{"location":"api/#SuperLU.superlu_solve!","page":"API Reference","title":"SuperLU.superlu_solve!","text":"superlu_solve!(F::SuperLUFactorize, b::AbstractVector; trans::trans_t=NOTRANS)\n\nSolve the linear system using a previously computed LU factorization. The solution overwrites b.\n\n\n\n\n\n","category":"function"},{"location":"api/#SuperLU.superlu_solve","page":"API Reference","title":"SuperLU.superlu_solve","text":"superlu_solve(F::SuperLUFactorize, b::AbstractVector; trans::trans_t=NOTRANS)\n\nSolve the linear system using a previously computed LU factorization. Returns a new vector with the solution.\n\n\n\n\n\n","category":"function"},{"location":"api/#SuperLU.update_matrix!","page":"API Reference","title":"SuperLU.update_matrix!","text":"update_matrix!(F::SuperLUFactorize, A::SparseMatrixCSC)\n\nUpdate the matrix in an existing factorization object with new values. The sparsity pattern must remain the same. After calling this, you must call factorize! again before solving.\n\n\n\n\n\n","category":"function"},{"location":"api/#SuperLU.trans_t","page":"API Reference","title":"SuperLU.trans_t","text":"trans_t\n\nTranspose type enumeration for solve operations.\n\nValues\n\nNOTRANS: No transpose (solve Ax = b)\nTRANS: Transpose (solve Aᵀx = b)\nCONJ: Conjugate transpose (solve Aᴴx = b)\n\n\n\n\n\n","category":"type"},{"location":"api/#SuperLU.colperm_t","page":"API Reference","title":"SuperLU.colperm_t","text":"colperm_t\n\nColumn permutation strategy enumeration for SuperLU.\n\nColumn permutation is used to reduce fill-in during factorization and improve performance. Different strategies trade off between quality and computation time.\n\nValues\n\nNATURAL: Natural ordering (no permutation)\nMMD_ATA: Minimum degree ordering on AᵀA (for non-symmetric matrices)\nMMD_AT_PLUS_A: Minimum degree ordering on Aᵀ+A (for nearly symmetric matrices)\nCOLAMD: Column approximate minimum degree (recommended for general matrices)\nMETIS_AT_PLUS_A: METIS nested dissection on Aᵀ+A\nPARMETIS: ParMETIS parallel ordering (for distributed matrices)\nZOLTAN: Zoltan hypergraph partitioning\nMY_PERMC: User-supplied column permutation\n\nRecommendations\n\nFor general matrices: COLAMD (default in SuperLU)\nFor symmetric or nearly symmetric: MMD_AT_PLUS_A\nFor large matrices where quality matters: METIS_AT_PLUS_A\n\n\n\n\n\n","category":"type"},{"location":"api/#SuperLU.rowperm_t","page":"API Reference","title":"SuperLU.rowperm_t","text":"rowperm_t\n\nRow permutation strategy enumeration for SuperLU.\n\nRow permutation is used for numerical stability during factorization.\n\nValues\n\nNOROWPERM: No row permutation (faster but may be less stable)\nLargeDiag_MC64: Move largest entries to diagonal using MC64 algorithm\nLargeDiag_HWPM: Hungarian algorithm for weighted perfect matching\nMY_PERMR: User-supplied row permutation\n\nRecommendations\n\nFor well-conditioned matrices: NOROWPERM\nFor general matrices: LargeDiag_MC64 (recommended for stability)\n\n\n\n\n\n","category":"type"},{"location":"api/#SuperLU.IterRefine_t","page":"API Reference","title":"SuperLU.IterRefine_t","text":"IterRefine_t\n\nIterative refinement strategy enumeration for SuperLU.\n\nIterative refinement improves the accuracy of the solution at the cost of additional computation. It is particularly useful for ill-conditioned systems.\n\nValues\n\nNOREFINE: No iterative refinement (fastest)\nSLU_SINGLE: Single precision iterative refinement\nSLU_DOUBLE: Double precision iterative refinement\nSLU_EXTRA: Extra precision iterative refinement (most accurate)\n\nRecommendations\n\nFor well-conditioned systems: NOREFINE\nFor improved accuracy: SLU_DOUBLE\n\n\n\n\n\n","category":"type"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"This guide will help you get started with SuperLU.jl for solving sparse linear systems.","category":"section"},{"location":"getting_started/#Basic-Usage","page":"Getting Started","title":"Basic Usage","text":"","category":"section"},{"location":"getting_started/#Direct-API","page":"Getting Started","title":"Direct API","text":"The simplest way to use SuperLU.jl is through its direct API:\n\nusing SuperLU\nusing SparseArrays\n\n# Create a sparse complex matrix\nA = sparse([1.0+1.0im 2.0+0im 0.0; \n            3.0-1.0im 4.0+2.0im 1.0+0im; \n            0.0 1.0+1.0im 5.0-1.0im])\nb = [1.0+0im, 2.0+1.0im, 3.0-1.0im]\n\n# Create factorization and solve\nF = SuperLUFactorize(A)\nfactorize!(F)\nx = copy(b)\nsuperlu_solve!(F, x)","category":"section"},{"location":"getting_started/#LinearSolve.jl-Integration","page":"Getting Started","title":"LinearSolve.jl Integration","text":"For a more convenient interface, SuperLU.jl integrates with LinearSolve.jl. This integration is provided via a package extension that loads automatically when both packages are loaded:\n\nusing SuperLU\nusing LinearSolve\nusing SparseArrays\n\nA = sparse([1.0+1.0im 2.0+0im 0.0; \n            3.0-1.0im 4.0+2.0im 1.0+0im; \n            0.0 1.0+1.0im 5.0-1.0im])\nb = [1.0+0im, 2.0+1.0im, 3.0-1.0im]\n\nprob = LinearProblem(A, b)\nsol = solve(prob, SuperLUFactorization())","category":"section"},{"location":"getting_started/#Reusing-Factorization","page":"Getting Started","title":"Reusing Factorization","text":"When solving multiple systems with the same sparsity pattern but different values, you can reuse the symbolic factorization for better performance:\n\nusing SuperLU\nusing LinearSolve\nusing SparseArrays\n\nA1 = sparse([4.0+1.0im 1.0+0im 0.0; \n             1.0-1.0im 4.0+2.0im 1.0+0im; \n             0.0 1.0+1.0im 4.0-1.0im])\nb1 = [1.0+0im, 2.0+1.0im, 3.0-1.0im]\n\n# First solve with reuse_symbolic=true (default)\nprob1 = LinearProblem(A1, b1)\ncache = init(prob1, SuperLUFactorization(reuse_symbolic=true))\nsol1 = solve!(cache)\n\n# Update matrix values (same pattern) and solve again\nA2 = sparse([5.0+2.0im 2.0+0im 0.0; \n             2.0-1.0im 5.0+1.0im 2.0+0im; \n             0.0 2.0+1.0im 5.0-2.0im])\nb2 = [2.0+1.0im, 3.0-1.0im, 4.0+0im]\n\ncache.A = A2\ncache.b = b2\ncache.isfresh = true\nsol2 = solve!(cache)","category":"section"},{"location":"options/#Solver-Options","page":"Solver Options","title":"Solver Options","text":"SuperLU.jl provides configurable options for customizing solver behavior. These options control various aspects of the factorization and solve process, including permutation strategies, pivoting, and iterative refinement.","category":"section"},{"location":"options/#SuperLUOptions","page":"Solver Options","title":"SuperLUOptions","text":"The SuperLUOptions struct provides a user-friendly interface for configuring the SuperLU solver. All options have sensible defaults for general use cases.\n\nusing SuperLU\n\n# Create options with all defaults\nopts = SuperLUOptions()\n\n# Create options with custom settings\nopts = SuperLUOptions(\n    col_perm = METIS_AT_PLUS_A,      # Use METIS for column ordering\n    equilibrate = true,               # Enable matrix equilibration\n    iterative_refinement = SLU_DOUBLE # Enable double precision refinement\n)\n\n# Use options with factorization\nF = SuperLUFactorize(A; options=opts)\nfactorize!(F)","category":"section"},{"location":"options/#Permutation-Strategies","page":"Solver Options","title":"Permutation Strategies","text":"","category":"section"},{"location":"options/#Column-Permutation-(col_perm)","page":"Solver Options","title":"Column Permutation (col_perm)","text":"Column permutation reorders the columns of the matrix to reduce fill-in during LU factorization. The choice of strategy can significantly impact both performance and memory usage.\n\nStrategy Description Best For\nNATURAL No permutation Already well-ordered matrices\nMMD_ATA Minimum degree on AᵀA General non-symmetric matrices\nMMD_AT_PLUS_A Minimum degree on Aᵀ+A Nearly symmetric matrices\nCOLAMD Column approximate minimum degree General matrices (default)\nMETIS_AT_PLUS_A METIS nested dissection Large matrices where quality matters\n\nExample:\n\n# For a symmetric or nearly symmetric matrix\nopts = SuperLUOptions(col_perm = MMD_AT_PLUS_A)\n\n# For large matrices where fill-in reduction is critical\nopts = SuperLUOptions(col_perm = METIS_AT_PLUS_A)","category":"section"},{"location":"options/#Row-Permutation-(row_perm)","page":"Solver Options","title":"Row Permutation (row_perm)","text":"Row permutation is used for numerical stability during factorization. It helps ensure that the diagonal elements are sufficiently large.\n\nStrategy Description Best For\nNOROWPERM No row permutation Well-conditioned matrices\nLargeDiag_MC64 MC64 weighted matching General matrices (recommended)\nLargeDiag_HWPM Hungarian algorithm Alternative to MC64\n\nExample:\n\n# For well-conditioned matrices (faster)\nopts = SuperLUOptions(row_perm = NOROWPERM)\n\n# For general matrices (more stable)\nopts = SuperLUOptions(row_perm = LargeDiag_MC64)","category":"section"},{"location":"options/#Numerical-Options","page":"Solver Options","title":"Numerical Options","text":"","category":"section"},{"location":"options/#Equilibration-(equilibrate)","page":"Solver Options","title":"Equilibration (equilibrate)","text":"Matrix equilibration (scaling) can improve numerical stability by making the matrix rows and columns have similar norms.\n\n# Enable equilibration (default: true)\nopts = SuperLUOptions(equilibrate = true)\n\n# Disable equilibration for already well-scaled matrices\nopts = SuperLUOptions(equilibrate = false)","category":"section"},{"location":"options/#Diagonal-Pivot-Threshold-(diag_pivot_thresh)","page":"Solver Options","title":"Diagonal Pivot Threshold (diag_pivot_thresh)","text":"Controls the preference for diagonal elements during pivoting. The value should be between 0.0 and 1.0.\n\n1.0: Always prefer diagonal elements (partial pivoting, default)\n0.0: Never prefer diagonal elements (complete pivoting)\nValues in between: Threshold for when to consider off-diagonal elements\n\n# Default: partial pivoting\nopts = SuperLUOptions(diag_pivot_thresh = 1.0)\n\n# More aggressive pivoting for ill-conditioned matrices\nopts = SuperLUOptions(diag_pivot_thresh = 0.1)","category":"section"},{"location":"options/#Symmetric-Mode-(symmetric_mode)","page":"Solver Options","title":"Symmetric Mode (symmetric_mode)","text":"When enabled, uses symmetric storage and factorization patterns. Only applicable to structurally symmetric matrices.\n\n# For symmetric matrices\nopts = SuperLUOptions(symmetric_mode = true)","category":"section"},{"location":"options/#Iterative-Refinement","page":"Solver Options","title":"Iterative Refinement","text":"Iterative refinement improves solution accuracy at the cost of additional computation. It is particularly useful for ill-conditioned systems.\n\nStrategy Description Performance Impact\nNOREFINE No refinement Fastest\nSLU_SINGLE Single precision refinement Minor overhead\nSLU_DOUBLE Double precision refinement Moderate overhead\nSLU_EXTRA Extra precision refinement Most accurate but slowest\n\nExample:\n\n# For maximum accuracy\nopts = SuperLUOptions(iterative_refinement = SLU_DOUBLE)\n\n# For speed (no refinement)\nopts = SuperLUOptions(iterative_refinement = NOREFINE)","category":"section"},{"location":"options/#Diagnostic-Options","page":"Solver Options","title":"Diagnostic Options","text":"","category":"section"},{"location":"options/#Pivot-Growth-(pivot_growth)","page":"Solver Options","title":"Pivot Growth (pivot_growth)","text":"Computes the reciprocal pivot growth factor, which can be used to assess numerical stability.\n\nopts = SuperLUOptions(pivot_growth = true)","category":"section"},{"location":"options/#Condition-Number-(condition_number)","page":"Solver Options","title":"Condition Number (condition_number)","text":"Estimates the condition number of the matrix. Useful for detecting ill-conditioned systems.\n\nopts = SuperLUOptions(condition_number = true)","category":"section"},{"location":"options/#Print-Statistics-(print_stats)","page":"Solver Options","title":"Print Statistics (print_stats)","text":"Enables printing of solver statistics for debugging and performance analysis.\n\nopts = SuperLUOptions(print_stats = true)","category":"section"},{"location":"options/#Advanced-Options","page":"Solver Options","title":"Advanced Options","text":"","category":"section"},{"location":"options/#Replace-Tiny-Pivots-(replace_tiny_pivot)","page":"Solver Options","title":"Replace Tiny Pivots (replace_tiny_pivot)","text":"When enabled, very small pivot elements are replaced to improve stability. This can help with nearly singular matrices.\n\nopts = SuperLUOptions(replace_tiny_pivot = true)","category":"section"},{"location":"options/#Using-Options-with-LinearSolve.jl","page":"Solver Options","title":"Using Options with LinearSolve.jl","text":"Options can also be passed when using the LinearSolve.jl interface:\n\nusing SuperLU\nusing LinearSolve\nusing SparseArrays\n\nA = sparse([4.0+1.0im 1.0+0im; 1.0-1.0im 4.0+2.0im])\nb = [1.0+0im, 2.0+1.0im]\n\n# Create options\nopts = SuperLUOptions(\n    col_perm = METIS_AT_PLUS_A,\n    iterative_refinement = SLU_DOUBLE\n)\n\n# Use with LinearSolve\nprob = LinearProblem(A, b)\nsol = solve(prob, SuperLUFactorization(options = opts))","category":"section"},{"location":"options/#Recommended-Settings","page":"Solver Options","title":"Recommended Settings","text":"","category":"section"},{"location":"options/#General-Purpose","page":"Solver Options","title":"General Purpose","text":"opts = SuperLUOptions()  # All defaults are good for most cases","category":"section"},{"location":"options/#Maximum-Performance","page":"Solver Options","title":"Maximum Performance","text":"opts = SuperLUOptions(\n    col_perm = COLAMD,\n    row_perm = NOROWPERM,\n    equilibrate = false,\n    iterative_refinement = NOREFINE\n)","category":"section"},{"location":"options/#Maximum-Accuracy","page":"Solver Options","title":"Maximum Accuracy","text":"opts = SuperLUOptions(\n    col_perm = METIS_AT_PLUS_A,\n    row_perm = LargeDiag_MC64,\n    equilibrate = true,\n    iterative_refinement = SLU_DOUBLE,\n    diag_pivot_thresh = 1.0\n)","category":"section"},{"location":"options/#Ill-Conditioned-Matrices","page":"Solver Options","title":"Ill-Conditioned Matrices","text":"opts = SuperLUOptions(\n    equilibrate = true,\n    iterative_refinement = SLU_EXTRA,\n    replace_tiny_pivot = true,\n    condition_number = true  # To monitor the condition\n)","category":"section"},{"location":"#SuperLU.jl","page":"Home","title":"SuperLU.jl","text":"A Julia interface for SuperLU, a library for direct solution of large, sparse, non-symmetric systems of linear equations.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Complex double precision (ComplexF64) sparse matrix solver\nIntegration with LinearSolve.jl via package extension\nSupport for reusing factorization objects with updated matrix values\nGPU acceleration via CUDA.jl extension (experimental)","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"The package can be installed using Julia's package manager:\n\nusing Pkg\nPkg.add(\"SuperLU\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using SuperLU\nusing SparseArrays\n\n# Create a sparse complex matrix\nA = sparse([1.0+1.0im 2.0+0im 0.0; \n            3.0-1.0im 4.0+2.0im 1.0+0im; \n            0.0 1.0+1.0im 5.0-1.0im])\nb = [1.0+0im, 2.0+1.0im, 3.0-1.0im]\n\n# Create factorization and solve\nF = SuperLUFactorize(A)\nfactorize!(F)\nx = copy(b)\nsuperlu_solve!(F, x)\n\nSee the Getting Started guide for more detailed examples.","category":"section"},{"location":"#Contents","page":"Home","title":"Contents","text":"Pages = [\"getting_started.md\", \"options.md\", \"api.md\"]\nDepth = 2","category":"section"}]
}
