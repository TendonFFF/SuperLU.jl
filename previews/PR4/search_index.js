var documenterSearchIndex = {"docs":
[{"location":"#SuperLU.jl","page":"Home","title":"SuperLU.jl","text":"A Julia interface for SuperLU, a library for direct solution of large, sparse, non-symmetric systems of linear equations.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Complex double precision (ComplexF64) sparse matrix solver\nIntegration with LinearSolve.jl via package extension\nSupport for reusing factorization objects with updated matrix values\nGPU acceleration via CUDA.jl extension (experimental)","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"SuperLU\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#Direct-API","page":"Home","title":"Direct API","text":"using SuperLU\nusing SparseArrays\n\n# Create a sparse complex matrix\nA = sparse([1.0+1.0im 2.0+0im 0.0; \n            3.0-1.0im 4.0+2.0im 1.0+0im; \n            0.0 1.0+1.0im 5.0-1.0im])\nb = [1.0+0im, 2.0+1.0im, 3.0-1.0im]\n\n# Create factorization and solve\nF = SuperLUFactorize(A)\nfactorize!(F)\nx = copy(b)\nsuperlu_solve!(F, x)","category":"section"},{"location":"#LinearSolve.jl-Integration","page":"Home","title":"LinearSolve.jl Integration","text":"using SuperLU\nusing LinearSolve\nusing SparseArrays\n\nA = sparse([1.0+1.0im 2.0+0im 0.0; \n            3.0-1.0im 4.0+2.0im 1.0+0im; \n            0.0 1.0+1.0im 5.0-1.0im])\nb = [1.0+0im, 2.0+1.0im, 3.0-1.0im]\n\nprob = LinearProblem(A, b)\nsol = solve(prob, SuperLUFactorization())","category":"section"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"","category":"section"},{"location":"#SuperLU.SuperLUFactorization","page":"Home","title":"SuperLU.SuperLUFactorization","text":"SuperLUFactorization(; reuse_symbolic::Bool = true)\n\nA LinearSolve.jl compatible factorization algorithm using SuperLU for sparse matrices. Supports complex double precision (ComplexF64) matrices.\n\nRequires loading LinearSolve.jl to use with LinearSolve's solve interface.\n\nArguments\n\nreuse_symbolic::Bool = true: If true, the symbolic factorization from a  previous solve will be reused when solving with a new matrix that has the same  sparsity pattern. If false, a complete factorization is performed each time.\n\nExample\n\nusing SuperLU, LinearSolve, SparseArrays\n\nA = sparse([1.0+0im 2.0; 3.0 4.0])\nb = [1.0+0im, 2.0]\nprob = LinearProblem(A, b)\nsol = solve(prob, SuperLUFactorization())\n\n\n\n\n\n","category":"type"},{"location":"#SuperLU.SuperLUGPUFactorization","page":"Home","title":"SuperLU.SuperLUGPUFactorization","text":"SuperLUGPUFactorization(; reuse_symbolic::Bool = true)\n\nA GPU-accelerated variant of SuperLU factorization for sparse matrices. This requires a CUDA-capable GPU and the CUDA.jl package to be loaded.\n\nnote: GPU Support Status\nGPU support is currently experimental and requires CUDA.jl. When CUDA.jl is  loaded, the GPU-accelerated kernels will be used for the numerical factorization phase, while symbolic analysis is performed on the CPU.\n\nwarning: Requirements\nCUDA.jl package must be loaded\nNVIDIA GPU with CUDA support\nThe matrix must be on the CPU (data transfer is handled automatically)\n\nArguments\n\nreuse_symbolic::Bool = true: If true, the symbolic factorization from a  previous solve will be reused when solving with a new matrix that has the same  sparsity pattern.\n\nExample\n\nusing SuperLU, CUDA\nusing LinearSolve, SparseArrays\n\nA = sparse([1.0+0im 2.0; 3.0 4.0])\nb = [1.0+0im, 2.0]\nprob = LinearProblem(A, b)\nsol = solve(prob, SuperLUGPUFactorization())  # Uses GPU acceleration\n\nCurrent Limitations\n\nGPU acceleration uses CUDA for dense operations during factorization\nThe sparse matrix remains on the CPU; only intermediate dense computations benefit from GPU\nFor very large matrices, the GPU speedup can be significant\n\n\n\n\n\n","category":"type"},{"location":"#SuperLU.SuperLUFactorize","page":"Home","title":"SuperLU.SuperLUFactorize","text":"SuperLUFactorize\n\nA mutable struct that holds the LU factorization of a sparse matrix using SuperLU. This includes the L and U factors, permutation vectors, and other data needed for solving linear systems.\n\n\n\n\n\n","category":"type"},{"location":"#SuperLU.factorize!","page":"Home","title":"SuperLU.factorize!","text":"factorize!(F::SuperLUFactorize)\n\nPerform LU factorization using SuperLU.\n\n\n\n\n\n","category":"function"},{"location":"#SuperLU.superlu_solve!","page":"Home","title":"SuperLU.superlu_solve!","text":"superlu_solve!(F::SuperLUFactorize, b::AbstractVector; trans::trans_t=NOTRANS)\n\nSolve the linear system using a previously computed LU factorization. The solution overwrites b.\n\n\n\n\n\n","category":"function"},{"location":"#SuperLU.superlu_solve","page":"Home","title":"SuperLU.superlu_solve","text":"superlu_solve(F::SuperLUFactorize, b::AbstractVector; trans::trans_t=NOTRANS)\n\nSolve the linear system using a previously computed LU factorization. Returns a new vector with the solution.\n\n\n\n\n\n","category":"function"},{"location":"#SuperLU.update_matrix!","page":"Home","title":"SuperLU.update_matrix!","text":"update_matrix!(F::SuperLUFactorize, A::SparseMatrixCSC)\n\nUpdate the matrix in an existing factorization object with new values. The sparsity pattern must remain the same. After calling this, you must call factorize! again before solving.\n\n\n\n\n\n","category":"function"},{"location":"#SuperLU.is_gpu_available","page":"Home","title":"SuperLU.is_gpu_available","text":"is_gpu_available()\n\nCheck if GPU acceleration is available for SuperLU computations. Returns true if CUDA.jl is loaded and a compatible GPU is detected.\n\n\n\n\n\n","category":"function"}]
}
